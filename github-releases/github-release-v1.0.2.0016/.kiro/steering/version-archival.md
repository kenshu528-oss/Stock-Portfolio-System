# 版本歸檔規則 (Version Archival Rules)

## 🗂️ 核心原則：每版本完整保存

### 絕對要求的操作
- ✅ **每次上傳到 GitHub 前必須創建版本資料夾**
- ✅ **版本資料夾必須包含完整的專案檔案**
- ✅ **版本資料夾命名必須與版本號一致**
- ✅ **保留所有歷史版本以供回溯**

## 📂 資料夾結構規範

### 標準歸檔位置
```
github-releases/
├── github-release-v1.0.2.0001/
├── github-release-v1.0.2.0011/
├── github-release-v1.0.2.0012/
└── github-release-v1.0.2.XXXX/
```

### 版本資料夾命名規則
```
格式: github-release-v{MAJOR}.{MINOR}.{PATCH}.{BUILD}
範例: github-release-v1.0.2.0011
```

## 🔄 歸檔流程

### GitHub 上傳前必須執行
1. **檢查當前版本號**
2. **創建對應版本資料夾**
3. **複製完整專案檔案**
4. **驗證歸檔完整性**
5. **才能執行 GitHub 上傳**

### 必須歸檔的檔案
- ✅ 所有源代碼 (`src/` 目錄)
- ✅ 配置檔案 (`package.json`, `vite.config.ts` 等)
- ✅ 後端代碼 (`backend/` 目錄)
- ✅ 文檔檔案 (`README.md`, `LICENSE` 等)
- ✅ 建置配置 (`tsconfig.json`, `tailwind.config.js` 等)

### 不需要歸檔的檔案
- ❌ `node_modules/` 目錄
- ❌ `dist/` 目錄
- ❌ `.git/` 目錄
- ❌ 臨時檔案和快取

## 📋 歸檔檢查清單

### 每次 GitHub 上傳前必須確認
- [ ] 當前版本號是否正確？
- [ ] 版本資料夾是否已創建？
- [ ] 所有必要檔案是否已複製？
- [ ] 版本資料夾命名是否正確？
- [ ] 歷史版本是否完整保存？

## 🛠️ 自動化歸檔

### 歸檔命令範例
```bash
# 創建版本資料夾
mkdir github-releases/github-release-v1.0.2.XXXX

# 複製專案檔案（排除不需要的目錄）
robocopy . github-releases/github-release-v1.0.2.XXXX /E /XD node_modules dist .git export github-releases
```

### 歸檔驗證
```bash
# 檢查版本資料夾內容
dir github-releases/github-release-v1.0.2.XXXX

# 驗證關鍵檔案存在
- package.json
- src/ 目錄
- backend/ 目錄
- README.md
```

## 🚨 違規處理

### 如果發現未歸檔就上傳
1. **立即停止 GitHub 操作**
2. **創建當前版本的歸檔**
3. **驗證歸檔完整性**
4. **重新執行上傳流程**

### 歸檔失敗處理
1. **檢查磁碟空間**
2. **確認檔案權限**
3. **重新執行歸檔命令**
4. **驗證歸檔結果**

## 💡 最佳實踐

### 歸檔時機
- **開發完成後**
- **測試通過後**
- **準備上傳 GitHub 前**
- **版本號確定後**

### 歸檔管理
- 定期檢查歷史版本完整性
- 清理過舊的開發版本（保留重要里程碑）
- 記錄每個版本的主要變更
- 確保歸檔檔案的可讀性

## 🎯 歸檔目標

### 版本追溯能力
- **100%** 的發布版本都有完整歸檔
- **即時** 的版本回溯能力
- **完整** 的歷史變更記錄
- **可靠** 的版本恢復機制

### 開發流程整合
- **自動化** 的歸檔流程
- **標準化** 的資料夾結構
- **一致性** 的命名規則
- **可追溯** 的版本歷史

---

**記住：每個上傳到 GitHub 的版本都是重要的里程碑，必須完整保存以供未來參考和回溯！**